{% extends 'base-page.htt' %}

{% block extracss %}
<style>
	.backtest-layout {
		display: grid;
		grid-template-columns: 320px 1fr 300px;
		gap: 16px;
		padding: 16px;
		min-height: 600px;
	}
	.backtest-sidebar {
		background: #fff;
		border-radius: 6px;
		padding: 16px;
		box-shadow: 0 1px 3px rgba(0,0,0,0.1);
		text-align: left;
	}
	.backtest-sidebar h3 {
		margin-top: 0;
		margin-bottom: 12px;
		font-size: 14px;
		color: #003366;
	}
	.backtest-sidebar label {
		display: block;
		font-size: 12px;
		font-weight: 500;
		margin-bottom: 4px;
		color: #495057;
	}
	.backtest-sidebar select,
	.backtest-sidebar input[type="number"],
	.backtest-sidebar input[type="text"] {
		width: 100%;
		padding: 6px 10px;
		margin-bottom: 10px;
		border: 1px solid #ced4da;
		border-radius: 6px;
		font-size: 13px;
		box-sizing: border-box;
		font-family: inherit;
		background: #fff;
		color: #212529;
		transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
	}
	.backtest-sidebar select:focus,
	.backtest-sidebar input:focus {
		border-color: #86b7fe;
		outline: none;
		box-shadow: 0 0 0 3px rgba(13, 110, 253, 0.2);
	}
	#strategy-params-container {
		margin-top: 4px;
	}
	.param-fieldset {
		border: 1px solid #dee2e6;
		border-radius: 6px;
		padding: 10px 12px 4px;
		margin: 0 0 10px 0;
		text-align: left;
	}
	.param-fieldset legend {
		font-size: 11px;
		font-weight: 600;
		color: #003366;
		padding: 0 6px;
		margin-left: -4px;
	}
	.param-fieldset .param-row {
		margin-bottom: 8px;
	}
	.param-fieldset .param-row label {
		font-weight: normal;
		color: #495057;
		font-size: 11px;
	}
	.param-fieldset .param-row input[type="checkbox"] {
		-webkit-appearance: none;
		appearance: none;
		width: 16px;
		height: 16px;
		border: 2px solid #ced4da;
		border-radius: 4px;
		vertical-align: middle;
		cursor: pointer;
		position: relative;
		transition: background-color 0.15s, border-color 0.15s;
	}
	.param-fieldset .param-row input[type="checkbox"]:checked {
		background-color: #005599;
		border-color: #005599;
	}
	.param-fieldset .param-row input[type="checkbox"]:checked::after {
		content: '';
		position: absolute;
		left: 3px;
		top: 0px;
		width: 5px;
		height: 9px;
		border: solid #fff;
		border-width: 0 2px 2px 0;
		transform: rotate(45deg);
	}
	.param-fieldset .param-row input[type="checkbox"]:focus {
		box-shadow: 0 0 0 3px rgba(13, 110, 253, 0.2);
	}
	.param-row.param-disabled {
		opacity: 0.45;
		pointer-events: none;
	}
	.param-hint {
		display: inline-block;
		margin-left: 4px;
		cursor: help;
		position: relative;
		font-weight: bold;
		font-size: 12px;
		line-height: 1;
		vertical-align: middle;
	}
	.param-hint-question {
		color: #005599;
		border: 1px solid #005599;
		border-radius: 50%;
		width: 14px;
		height: 14px;
		text-align: center;
		font-size: 10px;
		line-height: 14px;
	}
	.param-hint-exclamation {
		color: #c62828;
		font-size: 14px;
	}
	.param-hint .param-tooltip {
		display: none;
		position: absolute;
		left: 50%;
		bottom: 120%;
		transform: translateX(-50%);
		background: #333;
		color: #fff;
		font-size: 11px;
		font-weight: normal;
		padding: 5px 8px;
		border-radius: 4px;
		white-space: nowrap;
		max-width: 360px;
		min-width: 200px;
		white-space: normal;
		z-index: 100;
		line-height: 1.3;
		pointer-events: none;
	}
	.param-hint:hover .param-tooltip {
		display: block;
	}
	.sidebar-buttons {
		display: flex;
		gap: 8px;
		margin-top: 8px;
	}
	#btn-run-backtest {
		flex: 1;
		padding: 10px;
		background: #005599;
		color: #fff;
		border: none;
		border-radius: 4px;
		font-size: 14px;
		cursor: pointer;
		font-family: inherit;
	}
	#btn-make-xml {
		padding: 10px 14px;
		background: #f9f9f9;
		color: #333;
		border: 1px solid #ccc;
		border-radius: 4px;
		font-size: 14px;
		cursor: pointer;
		font-family: inherit;
		white-space: nowrap;
	}
	#btn-make-xml:hover {
		background: #e9e9e9;
	}
	#btn-run-backtest:hover {
		background: #003366;
	}
	#btn-run-backtest:disabled {
		background: #999;
		cursor: not-allowed;
	}
	.xml-modal-overlay {
		display: none;
		position: fixed;
		inset: 0;
		background: rgba(0,0,0,0.5);
		z-index: 1000;
		justify-content: center;
		align-items: center;
	}
	.xml-modal-overlay.active {
		display: flex;
	}
	.xml-modal {
		background: #fff;
		border-radius: 8px;
		padding: 24px;
		max-width: 640px;
		width: 90%;
		max-height: 80vh;
		display: flex;
		flex-direction: column;
		box-shadow: 0 8px 32px rgba(0,0,0,0.3);
	}
	.xml-modal h3 {
		margin: 0 0 12px;
		font-size: 16px;
	}
	.xml-modal textarea {
		flex: 1;
		min-height: 200px;
		font-family: 'Fira Code', monospace;
		font-size: 10px;
		border: 1px solid #ccc;
		border-radius: 4px;
		padding: 10px;
		resize: vertical;
		tab-size: 4;
		white-space: pre;
		overflow: auto;
	}
	.xml-modal-buttons {
		display: flex;
		gap: 8px;
		margin-top: 12px;
		justify-content: flex-end;
	}
	.xml-modal-buttons button {
		padding: 8px 16px;
		border-radius: 4px;
		font-size: 13px;
		cursor: pointer;
		font-family: inherit;
	}
	#btn-xml-copy {
		background: #005599;
		color: #fff;
		border: none;
	}
	#btn-xml-copy:hover {
		background: #003366;
	}
	#btn-xml-close {
		background: #f9f9f9;
		border: 1px solid #ccc;
	}
	#btn-xml-close:hover {
		background: #e9e9e9;
	}
	.sidebar-btn-secondary {
		flex: 1;
		padding: 8px 10px;
		background: #f9f9f9;
		color: #333;
		border: 1px solid #ccc;
		border-radius: 4px;
		font-size: 12px;
		cursor: pointer;
		font-family: inherit;
		white-space: nowrap;
	}
	.sidebar-btn-secondary:hover {
		background: #e9e9e9;
	}
	.load-config-list {
		list-style: none;
		padding: 0;
		margin: 0;
		max-height: 400px;
		overflow-y: auto;
	}
	.load-config-list li {
		padding: 10px 12px;
		cursor: pointer;
		border-bottom: 1px solid #eee;
		font-size: 13px;
	}
	.load-config-list li:hover {
		background: #e8f4fd;
	}
	.load-config-list li .pair-label {
		font-weight: 600;
		color: #003366;
	}
	.load-config-list li .pair-meta {
		font-size: 11px;
		color: #666;
		margin-top: 2px;
	}
	.backtest-main {
		display: flex;
		flex-direction: column;
		gap: 12px;
		align-self: start;
	}
	.chart-container {
		background: #fff;
		border-radius: 6px;
		box-shadow: 0 1px 3px rgba(0,0,0,0.1);
		position: relative;
		height: 640px;
	}
	#chart {
		width: 100%;
		height: 100%;
	}
	.playback-controls {
		background: #fff;
		border-radius: 6px;
		padding: 10px 16px;
		box-shadow: 0 1px 3px rgba(0,0,0,0.1);
		display: flex;
		align-items: center;
		gap: 12px;
		font-size: 13px;
	}
	.playback-controls button {
		padding: 6px 14px;
		border: 1px solid #ccc;
		border-radius: 4px;
		background: #f9f9f9;
		cursor: pointer;
		font-size: 13px;
		font-family: inherit;
	}
	.playback-controls button:hover {
		background: #e9e9e9;
	}
	#btn-abort {
		background: #fff0f0;
		border-color: #e88;
		color: #c44;
	}
	#btn-abort:hover:not(:disabled) {
		background: #ffe0e0;
	}
	#btn-abort:disabled {
		opacity: 0.4;
		cursor: default;
	}
	.speed-control {
		display: flex;
		align-items: center;
		gap: 6px;
	}
	.speed-control input[type="range"] {
		width: 100px;
	}
	#progress-bar-container {
		flex: 1;
		height: 6px;
		background: #e0e0e0;
		border-radius: 3px;
		overflow: hidden;
	}
	#progress-bar {
		height: 100%;
		width: 0%;
		background: #005599;
		transition: width 0.2s;
	}
	#progress-text {
		min-width: 80px;
		text-align: right;
		color: #666;
		font-size: 12px;
	}
	/* Right sidebar */
	.backtest-right-sidebar {
		display: flex;
		flex-direction: column;
		gap: 12px;
	}
	.right-sidebar-panel {
		background: #fff;
		border-radius: 6px;
		padding: 14px;
		box-shadow: 0 1px 3px rgba(0,0,0,0.1);
	}
	.right-sidebar-panel h3 {
		margin: 0 0 10px 0;
		font-size: 13px;
		color: #003366;
		text-transform: uppercase;
		letter-spacing: 0.5px;
	}
	.info-item {
		display: flex;
		justify-content: space-between;
		align-items: baseline;
		padding: 4px 0;
		line-height: 18px;
		border-bottom: 1px solid #f0f0f0;
	}
	.info-item:last-child { border-bottom: none; }
	.info-item .info-label {
		font-size: 11px;
		color: #999;
		text-transform: uppercase;
		flex-shrink: 0;
	}
	.info-item .info-value {
		font-size: 12px;
		font-weight: bold;
		color: #333;
		text-align: right;
	}
	.info-value.positive { color: #2e7d32; }
	.info-value.negative { color: #c62828; }
	/* DCA grid tables */
	.dca-grid-section { margin-bottom: 12px; }
	.dca-grid-section:last-child { margin-bottom: 0; }
	.dca-grid-table {
		width: 100%;
		border-collapse: collapse;
		font-size: 11px !important;
	}
	.dca-grid-table caption {
		text-align: left;
		font-weight: bold;
        font-size: 11px !important;
		color: #003366;
		padding-bottom: 4px;
	}
	.dca-grid-table th {
		background: #5c7589;
		color: #dfefff;
		padding: 4px 6px;
		text-align: right;
		font-weight: normal;
        font-size: 11px !important;
		text-transform: uppercase;
	}
	.dca-grid-table th:first-child { text-align: center; }
	.dca-grid-table td {
		padding: 3px 6px;
		text-align: right;
	}
	.dca-grid-table td:first-child { text-align: center; }
	.dca-grid-table tr:nth-child(even) td { background: #f9f9f9; }
	.dca-grid-table .offset-danger { color: #c62828; font-weight: bold; }
	.dca-grid-table tr.grid-filled td { background: #e8f5e9; }
	.dca-grid-footer {
		font-size: 10px;
		color: #666;
		line-height: 1.6;
		background: #eef1f4;
		padding: 6px 8px;
		text-align: left;
	}
	.dca-grid-footer strong { color: #333; }
	#dca-grids-container .dca-empty-hint {
		color: #999;
		font-size: 12px;
		font-style: italic;
	}
	.info-value.liquidated { color: #c62828; font-weight: bold; }
	#status-text {
		font-size: 12px;
		color: #666;
		font-style: italic;
	}
</style>
{% endblock %}

{% block content %}
<div class="backtest-layout">
	<div class="backtest-sidebar">
		<h3>Backtest Configuration</h3>

		<label for="sel-pair">Pair</label>
		<select id="sel-pair">
			<option value="">Loading...</option>
		</select>

		<label for="sel-strategy">Strategy</label>
		<select id="sel-strategy">
			<option value="">Loading...</option>
		</select>

		<div id="strategy-params-container"></div>

		<label for="inp-days">Period (days)</label>
		<input type="number" id="inp-days" value="30" min="1" max="365">

		<label for="inp-balance">Initial Balance (USDT)</label>
		<input type="number" id="inp-balance" value="1000" min="10" step="100">

		<label for="sel-ticks">Ticks per candle</label>
		<select id="sel-ticks">
			<option value="4" selected>4 (fast)</option>
			<option value="8">8</option>
			<option value="16">16</option>
			<option value="32">32 (precise)</option>
		</select>

		<div class="sidebar-buttons">
			<button id="btn-run-backtest">Run Backtest</button>
			<button id="btn-make-xml">Make XML</button>
		</div>
		<div class="sidebar-buttons" style="margin-top:4px;">
			<button id="btn-load-config" class="sidebar-btn-secondary">Load from Config</button>
			<button id="btn-load-xml" class="sidebar-btn-secondary">Load XML</button>
		</div>
		<div id="status-text"></div>
	</div>

	<div class="backtest-main">
		<div class="chart-container">
			<div id="chart"></div>
		</div>

		<div class="playback-controls">
			<button id="btn-clear">Clear</button>
			<button id="btn-abort" disabled>Abort</button>
			<div class="speed-control">
				<span>Speed:</span>
				<input type="range" id="speed-slider" min="0" max="6" value="3" step="1">
				<span id="speed-label">10/s</span>
			</div>
			<div id="progress-bar-container">
				<div id="progress-bar"></div>
			</div>
			<span id="progress-text">0 / 0</span>
		</div>

	</div>

	<div class="backtest-right-sidebar">
		<div class="right-sidebar-panel">
			<h3>Simulation</h3>
			<div class="info-item">
				<span class="info-label">Balance</span>
				<span class="info-value" id="info-balance">--</span>
			</div>
			<div class="info-item">
				<span class="info-label">Position</span>
				<span class="info-value" id="info-position">--</span>
			</div>
			<div class="info-item">
				<span class="info-label">Realized PnL</span>
				<span class="info-value" id="info-pnl">--</span>
			</div>
			<div class="info-item">
				<span class="info-label">Status</span>
				<span class="info-value" id="info-status">Idle</span>
			</div>
		</div>

		<div class="right-sidebar-panel" id="results-panel" style="display:none;">
			<h3>Results</h3>
			<div id="results-grid"></div>
		</div>

		<div class="right-sidebar-panel" id="dca-grids-panel">
			<h3>Order Grid</h3>
			<div id="dca-grids-container"></div>
		</div>
	</div>
</div>

<div class="xml-modal-overlay" id="xml-modal-overlay">
	<div class="xml-modal">
		<h3>Pair XML configuration</h3>
		<textarea id="xml-output" readonly></textarea>
		<div class="xml-modal-buttons">
			<button id="btn-xml-copy">Copy</button>
			<button id="btn-xml-close">Close</button>
		</div>
	</div>
</div>

<div class="xml-modal-overlay" id="load-config-overlay">
	<div class="xml-modal">
		<h3>Load from Config</h3>
		<ul class="load-config-list" id="load-config-list"></ul>
		<div class="xml-modal-buttons">
			<button id="btn-load-config-close" style="background:#f9f9f9;border:1px solid #ccc;">Close</button>
		</div>
	</div>
</div>

<div class="xml-modal-overlay" id="load-xml-overlay">
	<div class="xml-modal">
		<h3>Load XML</h3>
		<textarea id="load-xml-input" placeholder="Paste &lt;pair&gt;...&lt;/pair&gt; XML here"></textarea>
		<div class="xml-modal-buttons">
			<button id="btn-load-xml-apply" style="background:#005599;color:#fff;border:none;">Apply</button>
			<button id="btn-load-xml-close" style="background:#f9f9f9;border:1px solid #ccc;">Close</button>
		</div>
	</div>
</div>

<script src="https://unpkg.com/lightweight-charts@4.2.2/dist/lightweight-charts.standalone.production.js"></script>
<script>
(function() {
	'use strict';

	// =========================================================================
	// Speed steps: index -> candles per second (0 = instant)
	// =========================================================================
	const SPEED_STEPS = [1, 2, 5, 10, 25, 50, 0];
	const SPEED_LABELS = ['1/s', '2/s', '5/s', '10/s', '25/s', '50/s', '\u221E'];

	// =========================================================================
	// State
	// =========================================================================
	let strategies = [];
	let pairs = [];
	let eventBuffer = [];
	let playbackSpeed = SPEED_STEPS[3]; // 10/s default
	let playbackTimer = null;
	let totalCandles = 0;
	let renderedCandles = 0;
	let sessionId = null;
	let sseSource = null;
	let initialBalance = 0;
	let currentBalance = 0;
	let realizedBalance = 0;
	let currentPosition = null;
	let dcaFilledLevel = 0; // Highest filled DCA level (0 = entry only).

	// Liquidation alarm sound (preloaded).
	const liquidationSound = new Audio('/extras/liquidated.m4a');
	liquidationSound.preload = 'auto';

	// TradingView chart objects.
	let chart = null;
	let candleSeries = null;
	let bbUpperSeries = null;
	let bbMiddleSeries = null;
	let bbLowerSeries = null;
	let markers = [];

	// =========================================================================
	// DOM references
	// =========================================================================
	const elPair = document.getElementById('sel-pair');
	const elStrategy = document.getElementById('sel-strategy');
	const elParamsContainer = document.getElementById('strategy-params-container');
	const elDays = document.getElementById('inp-days');
	const elBalance = document.getElementById('inp-balance');
	const elRunBtn = document.getElementById('btn-run-backtest');
	const elMakeXmlBtn = document.getElementById('btn-make-xml');
	const elXmlOverlay = document.getElementById('xml-modal-overlay');
	const elXmlOutput = document.getElementById('xml-output');
	const elXmlCopy = document.getElementById('btn-xml-copy');
	const elXmlClose = document.getElementById('btn-xml-close');
	const elStatusText = document.getElementById('status-text');
	const elClearBtn = document.getElementById('btn-clear');
	const elAbortBtn = document.getElementById('btn-abort');
	const elSpeedSlider = document.getElementById('speed-slider');
	const elSpeedLabel = document.getElementById('speed-label');
	const elProgressBar = document.getElementById('progress-bar');
	const elProgressText = document.getElementById('progress-text');
	const elInfoBalance = document.getElementById('info-balance');
	const elInfoPosition = document.getElementById('info-position');
	const elInfoPnl = document.getElementById('info-pnl');
	const elInfoStatus = document.getElementById('info-status');
	const elResultsPanel = document.getElementById('results-panel');
	const elResultsGrid = document.getElementById('results-grid');
	const elDCAGridsPanel = document.getElementById('dca-grids-panel');
	const elDCAGridsContainer = document.getElementById('dca-grids-container');

	// =========================================================================
	// Initialization
	// =========================================================================
	async function init() {
		const [stratResp, pairsResp] = await Promise.all([
			fetch('/cgi-bin/api.pl?action=get_strategies'),
			fetch('/cgi-bin/api.pl?action=get_pairs'),
		]);
		strategies = await stratResp.json();
		pairs = await pairsResp.json();

		// Populate pairs dropdown (each exchange+ticker+marketType+timeframe combo is unique).
		elPair.innerHTML = '';
		pairs.forEach(p => {
			const opt = document.createElement('option');
			opt.value = JSON.stringify(p);
			opt.textContent = p.ticker + ' (' + p.exchange + ' ' + p.marketType + ' ' + p.timeframe + ')';
			elPair.appendChild(opt);
		});

		// Populate strategies dropdown.
		elStrategy.innerHTML = '';
		strategies.forEach(s => {
			const opt = document.createElement('option');
			opt.value = s.name;
			opt.textContent = s.displayName || s.name;
			elStrategy.appendChild(opt);
		});
		renderStrategyParams();

		// Initialize the chart.
		initChart();

		// Apply retest XML from Results page if present.
		var retestXml = sessionStorage.getItem('retest_xml');
		if (retestXml) {
			sessionStorage.removeItem('retest_xml');
			var retestExchange = sessionStorage.getItem('retest_exchange') || '';
			var retestMarketType = sessionStorage.getItem('retest_market_type') || '';
			sessionStorage.removeItem('retest_exchange');
			sessionStorage.removeItem('retest_market_type');
			parseAndApplyXml(retestXml, retestExchange, retestMarketType);
		}
	}

	/** Create hint icon(s) for a parameter (question mark and/or exclamation mark). */
	function createParamHints(p) {
		const frag = document.createDocumentFragment();
		if (p.exclamationMark) {
			const span = document.createElement('span');
			span.className = 'param-hint param-hint-exclamation';
			span.textContent = '\u26A0';
			const tip = document.createElement('span');
			tip.className = 'param-tooltip';
			tip.textContent = p.exclamationMark;
			span.appendChild(tip);
			frag.appendChild(span);
		}
		if (p.questionMark) {
			const span = document.createElement('span');
			span.className = 'param-hint param-hint-question';
			span.textContent = '?';
			const tip = document.createElement('span');
			tip.className = 'param-tooltip';
			tip.textContent = p.questionMark;
			span.appendChild(tip);
			frag.appendChild(span);
		}
		return frag;
	}

	function buildParamControl(p) {
		const row = document.createElement('div');
		row.className = 'param-row';
		const lbl = document.createElement('label');
		lbl.setAttribute('for', 'param-' + p.key);

		let control;
		switch (p.type) {
			case 'bool':
				control = document.createElement('input');
				control.type = 'checkbox';
				control.id = 'param-' + p.key;
				control.name = p.key;
				control.dataset.paramType = 'bool';
				control.checked = (p.default === 'true' || p.default === '1' || p.default === 'yes');
				lbl.style.display = 'inline';
				lbl.style.marginLeft = '6px';
				lbl.style.cursor = 'pointer';
				lbl.textContent = p.label;
				row.appendChild(control);
				row.appendChild(lbl);
				row.appendChild(createParamHints(p));
				return row;

			case 'int':
				control = document.createElement('input');
				control.type = 'number';
				control.step = '1';
				control.min = '0';
				control.value = p.default;
				break;

			case 'float':
				control = document.createElement('input');
				control.type = 'number';
				control.step = 'any';
				control.min = '0';
				control.value = p.default;
				break;

			case 'select':
				control = document.createElement('select');
				if (p.options) {
					Object.entries(p.options).forEach(([val, label]) => {
						const opt = document.createElement('option');
						opt.value = val;
						opt.textContent = label;
						if (val === p.default) opt.selected = true;
						control.appendChild(opt);
					});
				}
				break;

			default:
				control = document.createElement('input');
				control.type = 'text';
				control.value = p.default;
				break;
		}

		control.id = 'param-' + p.key;
		control.name = p.key;
		control.dataset.paramType = p.type;
		lbl.textContent = p.label;
		lbl.appendChild(createParamHints(p));
		row.appendChild(lbl);
		row.appendChild(control);
		return row;
	}

	function renderParamGroup(params, groupLabel) {
		const fieldset = document.createElement('fieldset');
		fieldset.className = 'param-fieldset';
		const legend = document.createElement('legend');
		legend.textContent = groupLabel;
		fieldset.appendChild(legend);
		params.forEach(p => fieldset.appendChild(buildParamControl(p)));
		return fieldset;
	}

	function renderStrategyParams() {
		const name = elStrategy.value;
		const strat = strategies.find(s => s.name === name);
		elParamsContainer.innerHTML = '';
		if (!strat) return;

		const btParams = strat.params.filter(p => p.backtestRelevant !== false);
		const nonBtParams = strat.params.filter(p => p.backtestRelevant === false);

		// Backtest-relevant params grouped by their original group.
		const groups = [];
		btParams.forEach(p => {
			if (!groups.includes(p.group)) groups.push(p.group);
		});
		groups.forEach(group => {
			const label = (group === strat.name) ? (strat.displayName || group) : group;
			elParamsContainer.appendChild(renderParamGroup(btParams.filter(p => p.group === group), label));
		});

		// Non-backtest-relevant params in a single separate fieldset.
		if (nonBtParams.length > 0) {
			elParamsContainer.appendChild(renderParamGroup(nonBtParams, 'Live Trading Only'));
		}

		// Wire up declarative dependencies (enabledWhen).
		applyParamDependencies(strat.params);

		// Attach live-update listeners for DCA grid preview.
		attachParamListeners();
		renderDCAGrids();
	}

	// =========================================================================
	// DCA Grid Preview
	// =========================================================================

	/** Collect current strategy params from the form. */
	function collectParams() {
		const params = {};
		elParamsContainer.querySelectorAll('input, select').forEach(el => {
			if (el.dataset.paramType === 'bool') {
				params[el.name] = el.checked ? 'true' : 'false';
			} else {
				params[el.name] = el.value;
			}
		});
		return params;
	}

	/**
	 * Apply declarative enabledWhen dependencies.
	 * For each param that declares enabledWhen, find the controlling checkbox
	 * and toggle enabled/disabled state of the dependent field.
	 */
	function applyParamDependencies(params) {
		params.forEach(p => {
			if (!p.enabledWhen) return;
			const depEl = document.getElementById('param-' + p.key);
			const ctrlEl = document.getElementById('param-' + p.enabledWhen.paramKey);
			if (!depEl || !ctrlEl) return;

			const row = depEl.closest('.param-row');
			const apply = () => {
				const currentVal = ctrlEl.type === 'checkbox'
					? (ctrlEl.checked ? 'true' : 'false')
					: ctrlEl.value;
				const enabled = currentVal === p.enabledWhen.value;
				depEl.disabled = !enabled;
				if (row) row.classList.toggle('param-disabled', !enabled);
			};

			apply();
			ctrlEl.addEventListener('change', apply);
		});
	}

	/** Attach input/change listeners to every param control. */
	function attachParamListeners() {
		elParamsContainer.querySelectorAll('input, select').forEach(el => {
			el.addEventListener('input', renderDCAGrids);
			el.addEventListener('change', renderDCAGrids);
		});
	}

	/** Parse entry volume string into {value, mode}. */
	function parseEntryVolume(raw) {
		const s = String(raw).trim();
		if (/^[\d.]+\s*%\s*[Mm]/i.test(s)) {
			return { value: parseFloat(s), mode: 'PERCENT_MARGIN' };
		}
		if (/^[\d.]+\s*%$/.test(s)) {
			return { value: parseFloat(s), mode: 'PERCENT_BALANCE' };
		}
		return { value: parseFloat(s) || 0, mode: 'ABSOLUTE' };
	}

	/** Resolve raw volume to USDT given mode and balance. */
	function resolveVolume(rawVolume, mode, balance) {
		switch (mode) {
			case 'PERCENT_BALANCE': return balance * (rawVolume / 100);
			case 'PERCENT_MARGIN':  return balance * (rawVolume / 100);
			default:                return rawVolume;
		}
	}

	/**
	 * Build a DCA grid (array of levels) from parameters.
	 * Mirrors PHP DCAOrderGrid::fromParameters + buildOrderMap.
	 */
	function buildDCAGrid(numLevels, entryVol, volMult, priceDev, priceDevMult, direction, offsetMode) {
		const sign = direction === 'LONG' ? -1 : 1;
		const levels = [];
		let volume = entryVol;

		// Phase 1: build raw level offsets (like fromParameters).
		const rawLevels = [];
		let currentDev = priceDev;
		for (let i = 0; i < numLevels; i++) {
			rawLevels.push({ volume: volume, offset: i === 0 ? 0 : currentDev });
			volume *= volMult;
			if (i > 0) currentDev *= priceDevMult;
		}

		// Phase 2: compute cumulative offsets (like buildOrderMap).
		if (offsetMode !== 'FROM_PREVIOUS') {
			// FROM_ENTRY: accumulate offsets.
			let total = 0;
			for (let i = 0; i < rawLevels.length; i++) {
				total += rawLevels[i].offset;
				levels.push({
					level: i === 0 ? 'Entry' : i,
					volume: rawLevels[i].volume,
					offset: sign * total,
				});
			}
		} else {
			// FROM_PREVIOUS: compound price ratio.
			let priceRatio = 1.0;
			for (let i = 0; i < rawLevels.length; i++) {
				const step = rawLevels[i].offset;
				if (step > 0) {
					priceRatio *= direction === 'LONG'
						? (1 - step / 100)
						: (1 + step / 100);
				}
				const absOffset = direction === 'LONG'
					? (1 - priceRatio) * 100
					: (priceRatio - 1) * 100;
				levels.push({
					level: i === 0 ? 'Entry' : i,
					volume: rawLevels[i].volume,
					offset: sign * absOffset,
				});
			}
		}
		return levels;
	}

	/** Render DCA grid tables in the right sidebar. */
	function renderDCAGrids() {
		const strat = strategies.find(s => s.name === elStrategy.value);
		if (!strat) {
			elDCAGridsPanel.style.display = 'none';
			return;
		}

		if (strat.type !== 'DCA') {
			elDCAGridsPanel.style.display = 'none';
			return;
		}

		elDCAGridsPanel.style.display = '';
		const params = collectParams();
		const balance = parseFloat(elBalance.value) || 0;
		const offsetMode = params.offsetMode || 'FROM_ENTRY';

		let html = '';

		// Long grid.
		const longLevels = parseInt(params.numberOfLevels) || 0;
		if (longLevels > 0) {
			const ev = parseEntryVolume(params.entryVolume || '100');
			const grid = buildDCAGrid(
				longLevels,
				ev.value,
				parseFloat(params.volumeMultiplier) || 1,
				parseFloat(String(params.priceDeviation || '0').replace('%', '')),
				parseFloat(params.priceDeviationMultiplier) || 1,
				'LONG', offsetMode
			);
			const ep = parseFloat(String(params.expectedProfit || '0').replace('%', ''));
			html += renderGridTable(grid, 'Long', ev.mode, balance, ep);
		}

		// Short grid.
		const shortLevels = parseInt(params.numberOfLevelsShort) || 0;
		if (shortLevels > 0) {
			const ev = parseEntryVolume(params.entryVolumeShort || '100');
			const grid = buildDCAGrid(
				shortLevels,
				ev.value,
				parseFloat(params.volumeMultiplierShort) || 1,
				parseFloat(String(params.priceDeviationShort || '0').replace('%', '')),
				parseFloat(params.priceDeviationMultiplierShort) || 1,
				'SHORT', offsetMode
			);
			const ep = parseFloat(String(params.expectedProfitShort || '0').replace('%', ''));
			html += renderGridTable(grid, 'Short', ev.mode, balance, ep);
		}

		if (!html) {
			html = '<p class="dca-empty-hint">No DCA levels configured.</p>';
		}

		elDCAGridsContainer.innerHTML = html;
	}

	/** Render a single grid direction into an HTML table string. */
	function renderGridTable(levels, label, volumeMode, balance, expectedProfit) {
		let totalVol = 0;
		let hasWarning = false;

		const dir = label === 'Long' ? 'LONG' : 'SHORT';
		let rows = '';
		for (let i = 0; i < levels.length; i++) {
			const lv = levels[i];
			const resolved = resolveVolume(lv.volume, volumeMode, balance);
			totalVol += resolved;
			const offsetDanger = (label === 'Long' && lv.offset < -100);
			if (offsetDanger) hasWarning = true;
			const offsetCls = offsetDanger ? ' class="offset-danger"' : '';
			rows += '<tr data-dir="' + dir + '" data-level="' + i + '">'
				+ '<td>' + escapeHtml(String(lv.level)) + '</td>'
				+ '<td>' + formatGridMoney(resolved) + '</td>'
				+ '<td' + offsetCls + '>' + lv.offset.toFixed(2) + '%</td>'
				+ '</tr>';
		}

		let s = '<div class="dca-grid-section">';
		s += '<table class="dca-grid-table">';
		s += '<caption>' + escapeHtml(label) + ' positions</caption>';
		s += '<thead><tr><th>Level</th><th>Volume</th><th>Offset</th></tr></thead>';
		s += '<tbody>' + rows + '</tbody>';

		// Footer with summary info.
		let footerLine1 = '';
		if (expectedProfit > 0) {
			footerLine1 += 'TP: <strong>' + expectedProfit.toFixed(2) + '%</strong>';
		}
		if (volumeMode !== 'ABSOLUTE') {
			const modeLabel = volumeMode === 'PERCENT_BALANCE' ? '% balance' : '% margin';
			if (footerLine1) footerLine1 += ' &middot; ';
			footerLine1 += 'Volume mode: <strong>' + modeLabel + '</strong>';
		}
		let footerLine2 = 'Max volume: <strong>' + formatGridMoney(totalVol) + '</strong>';
		if (hasWarning) {
			footerLine2 += '<br><span class="offset-danger">'
				+ '\u26A0 Offset below \u2212100%: orders at zero price will never fill'
				+ '</span>';
		}

		s += '<tfoot><tr><td colspan="3" class="dca-grid-footer">';
		if (footerLine1) s += footerLine1 + '<br>';
		s += footerLine2;
		s += '</td></tr></tfoot>';

		s += '</table>';
		s += '</div>';
		return s;
	}

	function formatGridMoney(v) {
		return v.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',') + ' USDT';
	}

	/** Highlight filled DCA levels in the order grid tables. */
	function updateGridHighlights() {
		const rows = elDCAGridsContainer.querySelectorAll('tr[data-dir][data-level]');
		rows.forEach(row => {
			const rowDir = row.dataset.dir;
			const rowLevel = parseInt(row.dataset.level);
			if (currentPosition && currentPosition.dir === rowDir && rowLevel <= dcaFilledLevel) {
				row.classList.add('grid-filled');
			} else {
				row.classList.remove('grid-filled');
			}
		});
	}

	let chartResizeObserver = null;

	function initChart() {
		const container = document.getElementById('chart');
		chart = LightweightCharts.createChart(container, {
			width: container.clientWidth,
			height: container.clientHeight || 400,
			layout: {
				background: { type: 'solid', color: '#ffffff' },
				textColor: '#333',
				fontFamily: 'Tahoma, Arial, sans-serif',
				fontSize: 12,
			},
			grid: {
				vertLines: { color: '#f0f0f0' },
				horzLines: { color: '#f0f0f0' },
			},
			crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
			timeScale: {
				timeVisible: true,
				secondsVisible: false,
			},
		});
		candleSeries = chart.addCandlestickSeries({
			upColor: '#26a69a',
			downColor: '#ef5350',
			borderVisible: false,
			wickUpColor: '#26a69a',
			wickDownColor: '#ef5350',
		});
		bbUpperSeries = chart.addLineSeries({ color: 'rgba(33, 150, 243, 0.4)', lineWidth: 1, priceLineVisible: false, lastValueVisible: false });
		bbMiddleSeries = chart.addLineSeries({ color: 'rgba(33, 150, 243, 0.6)', lineWidth: 1, lineStyle: 2, priceLineVisible: false, lastValueVisible: false });
		bbLowerSeries = chart.addLineSeries({ color: 'rgba(33, 150, 243, 0.4)', lineWidth: 1, priceLineVisible: false, lastValueVisible: false });

		// Resize handler.
		if (chartResizeObserver) {
			chartResizeObserver.disconnect();
		}
		chartResizeObserver = new ResizeObserver(entries => {
			const rect = entries[0].contentRect;
			chart.applyOptions({ width: rect.width, height: rect.height });
		});
		chartResizeObserver.observe(container);
	}

	/**
	 * Destroy the chart widget completely and recreate it from scratch.
	 * This resets the price scale so switching between assets with very
	 * different price ranges (e.g. 0.005 → 68000) works without manual
	 * zoom adjustments.
	 */
	function resetChart() {
		if (chart) {
			if (chartResizeObserver) {
				chartResizeObserver.disconnect();
				chartResizeObserver = null;
			}
			chart.remove();
			chart = null;
			candleSeries = null;
			bbUpperSeries = null;
			bbMiddleSeries = null;
			bbLowerSeries = null;
		}
		markers = [];
		initChart();
	}

	// =========================================================================
	// Event handling
	// =========================================================================
	elStrategy.addEventListener('change', renderStrategyParams);
	elBalance.addEventListener('input', renderDCAGrids);

	elSpeedSlider.addEventListener('input', () => {
		const idx = parseInt(elSpeedSlider.value);
		playbackSpeed = SPEED_STEPS[idx];
		elSpeedLabel.textContent = SPEED_LABELS[idx];
		// Restart the timer with the new speed if currently playing.
		if (playbackTimer) {
			stopPlaybackTimer();
			startPlaybackTimer();
		}
	});

	elClearBtn.addEventListener('click', clearChart);

	elAbortBtn.addEventListener('click', abortBacktest);

	elRunBtn.addEventListener('click', runBacktest);

	// =========================================================================
	// Run backtest
	// =========================================================================
	async function runBacktest() {
		const pairData = JSON.parse(elPair.value);
		const strategyName = elStrategy.value;
		const params = collectParams();

		const body = {
			pair: pairData.ticker,
			exchangeName: pairData.exchange,
			marketType: pairData.marketType,
			timeframe: pairData.timeframe,
			strategy: strategyName,
			params: params,
			days: parseInt(elDays.value),
			initialBalance: parseFloat(elBalance.value),
			ticksPerCandle: parseInt(document.getElementById('sel-ticks').value),
		};

		elRunBtn.disabled = true;
		elStatusText.textContent = 'Starting backtest...';
		elInfoStatus.textContent = 'Starting...';
		elResultsPanel.style.display = 'none';

		// Reset state.
		eventBuffer = [];
		renderedCandles = 0;
		totalCandles = 0;
		markers = [];
		currentPosition = null;
		dcaFilledLevel = 0;
		currentBalance = 0;
		realizedBalance = 0;
		initialBalance = body.initialBalance;

		// Fully recreate chart to reset price scale for the new asset.
		resetChart();

		try {
			const resp = await fetch('/cgi-bin/api.pl?action=run_backtest', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify(body),
			});
			const data = await resp.json();
			sessionId = data.sessionId;

			if (!sessionId) {
				elStatusText.textContent = 'Error: ' + (data.error || 'Unknown error');
				elRunBtn.disabled = false;
				return;
			}

			elStatusText.textContent = 'Backtest running, receiving events...';
			elInfoStatus.textContent = 'Running...';
			startSSE(sessionId);
			startPlaybackTimer();
			elAbortBtn.disabled = false;
		} catch (e) {
			elStatusText.textContent = 'Error: ' + e.message;
			elRunBtn.disabled = false;
		}
	}

	// =========================================================================
	// SSE Consumer
	// =========================================================================
	function startSSE(sid) {
		sseSource = new EventSource('/backtest-stream.php?id=' + sid);
		sseSource.onmessage = (e) => {
			try {
				const evt = JSON.parse(e.data);
				eventBuffer.push(evt);
			} catch (err) {
				// Ignore parse errors (e.g. keep-alive comments).
			}
		};
		sseSource.onerror = () => {
			sseSource.close();
			sseSource = null;
			elAbortBtn.disabled = true;
			if (elInfoStatus.textContent === 'Running...') {
				elInfoStatus.textContent = 'Disconnected';
				elStatusText.textContent = 'Connection to server lost.';
				elRunBtn.disabled = false;
			}
		};
	}

	// =========================================================================
	// Playback Engine
	// =========================================================================
	function startPlaybackTimer() {
		stopPlaybackTimer();
		if (playbackSpeed === 0) {
			// Instant mode: drain everything as fast as possible.
			playbackTimer = requestAnimationFrame(drainAll);
		} else {
			const intervalMs = 1000 / playbackSpeed;
			playbackTimer = setInterval(playbackTick, intervalMs);
		}
	}

	function stopPlaybackTimer() {
		if (playbackTimer) {
			clearInterval(playbackTimer);
			cancelAnimationFrame(playbackTimer);
			playbackTimer = null;
		}
	}

	function playbackTick() {
		// Process events from the buffer up to and including the next candle.
		// Non-candle events (position_open, balance, etc.) are consumed together
		// with their candle so they appear at the right moment.
		let foundCandle = false;
		while (eventBuffer.length > 0 && !foundCandle) {
			const evt = eventBuffer.shift();
			processEvent(evt);
			if (evt.type === 'candle') {
				foundCandle = true;
			}
		}
	}

	function drainAll() {
		// Instant mode: process a large batch per animation frame.
		const batchSize = 200;
		let processed = 0;
		while (processed < batchSize && eventBuffer.length > 0) {
			processEvent(eventBuffer.shift());
			processed++;
		}
		// Keep polling while SSE is still open, even if the buffer is
		// temporarily empty — new events will arrive shortly.
		if (eventBuffer.length > 0 || sseSource) {
			playbackTimer = requestAnimationFrame(drainAll);
		} else {
			playbackTimer = null;
		}
	}

	// =========================================================================
	// Abort Backtest
	// =========================================================================
	async function abortBacktest() {
		if (!sessionId) return;
		elAbortBtn.disabled = true;
		elStatusText.textContent = 'Aborting...';
		try {
			await fetch('/cgi-bin/api.pl?action=abort_backtest', {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ sessionId }),
			});
		} catch (e) {
			// Best effort — the stop file may not be created, but SSE will close naturally.
		}
	}

	// =========================================================================
	// Clear Chart
	// =========================================================================
	function clearChart() {
		// Stop any active SSE connection.
		if (sseSource) {
			sseSource.close();
			sseSource = null;
		}
		stopPlaybackTimer();

		// Reset state.
		eventBuffer = [];
		renderedCandles = 0;
		totalCandles = 0;
		markers = [];
		currentPosition = null;
		dcaFilledLevel = 0;
		currentBalance = 0;
		realizedBalance = 0;
		sessionId = null;

		// Fully recreate chart to reset price scale.
		resetChart();

		// Reset info panel.
		elInfoBalance.textContent = '--';
		elInfoPosition.textContent = '--';
		elInfoPnl.textContent = '--';
		elInfoPnl.className = 'info-value';
		elInfoStatus.textContent = 'Idle';
		elStatusText.textContent = '';
		elProgressBar.style.width = '0%';
		elProgressText.textContent = '0 / 0';

		// Hide results.
		elResultsPanel.style.display = 'none';

		// Re-enable run button, disable abort.
		elRunBtn.disabled = false;
		elAbortBtn.disabled = true;
	}

	// =========================================================================
	// Event Processor / Chart Renderer
	// =========================================================================
	function processEvent(evt) {
		switch (evt.type) {
			case 'init':
				totalCandles = evt.totalCandles;
				initialBalance = evt.initialBalance;
				currentBalance = evt.initialBalance;
				realizedBalance = evt.initialBalance;
				elInfoBalance.textContent = formatMoney(currentBalance);
				elProgressText.textContent = '0 / ' + totalCandles;
				break;

			case 'candle':
				renderCandle(evt);
				renderedCandles++;
				break;

			case 'position_open':
				currentPosition = { dir: evt.dir, price: evt.price, volume: evt.volume };
				dcaFilledLevel = 0;
				elInfoPosition.textContent = evt.dir + ' @ ' + evt.price.toFixed(4) + ' (' + formatMoney(evt.price * evt.volume) + ')';
				addMarker(evt.time, evt.dir === 'LONG' ? 'arrowUp' : 'arrowDown',
					evt.dir === 'LONG' ? '#26a69a' : '#ef5350',
					evt.dir === 'LONG' ? 'L' : 'S');
				updateGridHighlights();
				break;

			case 'position_close':
				currentPosition = null;
				dcaFilledLevel = 0;
				elInfoPosition.textContent = '--';
				const shape = evt.reason === 'TP' ? 'circle' : (evt.reason === 'SL' ? 'circle' : 'diamond');
				const color = evt.pnl >= 0 ? '#26a69a' : '#ef5350';
				addMarker(evt.time, shape, color, evt.reason);
				updateGridHighlights();
				break;

			case 'dca_fill':
				dcaFilledLevel++;
				if (currentPosition) {
					currentPosition.volume = evt.totalVolume;
					currentPosition.price = evt.newAvgEntry;
					elInfoPosition.textContent = currentPosition.dir + ' @ ' + evt.newAvgEntry.toFixed(4) + ' (' + formatMoney(evt.newAvgEntry * evt.totalVolume) + ')';
				}
				addMarker(evt.time, 'arrowUp', '#ff9800',
					evt.dir === 'LONG' ? 'DCA↓' : 'DCA↑');
				updateGridHighlights();
				break;

			case 'breakeven_lock':
				addMarker(evt.time, 'diamond', '#ff9800', 'BL');
				break;

			case 'partial_close':
				addMarker(evt.time, 'diamond', '#2196f3', 'PC');
				break;

			case 'balance':
				currentBalance = evt.value;
				realizedBalance = evt.realized ?? evt.value;
				elInfoBalance.textContent = formatMoney(currentBalance);
				updatePnl();
				break;

			case 'progress':
				elProgressBar.style.width = (evt.current / evt.total * 100) + '%';
				elProgressText.textContent = evt.current + ' / ' + evt.total;
				break;

			case 'result':
				showResults(evt);
				break;

			case 'error':
				elStatusText.textContent = 'Error: ' + evt.message;
				elInfoStatus.textContent = 'Error';
				elAbortBtn.disabled = true;
				break;

			case 'done':
				elInfoStatus.textContent = 'Completed';
				elStatusText.textContent = 'Backtest completed.';
				elRunBtn.disabled = false;
				elAbortBtn.disabled = true;
				stopPlaybackTimer();
				// Drain any remaining events instantly.
				while (eventBuffer.length > 0) {
					processEvent(eventBuffer.shift());
				}
				break;
		}
	}

	function renderCandle(evt) {
		const candleData = {
			time: evt.t,
			open: evt.o,
			high: evt.h,
			low: evt.l,
			close: evt.c,
		};
		candleSeries.update(candleData);

		// Bollinger Bands overlay.
		if (evt.ind) {
			if (evt.ind.bb_upper != null) {
				bbUpperSeries.update({ time: evt.t, value: evt.ind.bb_upper });
			}
			if (evt.ind.bb_middle != null) {
				bbMiddleSeries.update({ time: evt.t, value: evt.ind.bb_middle });
			}
			if (evt.ind.bb_lower != null) {
				bbLowerSeries.update({ time: evt.t, value: evt.ind.bb_lower });
			}
		}
	}

	function addMarker(time, shape, color, text) {
		markers.push({
			time: time,
			position: (shape === 'arrowUp') ? 'belowBar' : 'aboveBar',
			color: color,
			shape: shape,
			text: text,
		});
		// Markers must be sorted by time.
		markers.sort((a, b) => a.time - b.time);
		candleSeries.setMarkers(markers);
	}

	function updatePnl() {
		const pnl = realizedBalance - initialBalance;
		const pct = initialBalance > 0 ? (pnl / initialBalance * 100) : 0;
		const sign = pnl >= 0 ? '+' : '';
		elInfoPnl.textContent = sign + formatMoney(pnl) + ' (' + sign + pct.toFixed(1) + '%)';
		elInfoPnl.className = 'info-value ' + (pnl >= 0 ? 'positive' : 'negative');
	}

	function showResults(evt) {
		elResultsPanel.style.display = 'block';

		const pnlSign = evt.pnlPercent >= 0 ? '+' : '';
		const pnlClass = evt.pnl >= 0 ? 'positive' : 'negative';
		const items = [
			['Initial Balance', formatMoney(evt.initialBalance), ''],
			['Final Balance', formatMoney(evt.finalBalance), ''],
			['PnL', formatMoney(evt.pnl) + ' (' + pnlSign + evt.pnlPercent + '%)', pnlClass],
			['Total Fees', formatMoney(evt.totalFees ?? 0), ''],
			['Max Drawdown', formatMoney(evt.maxDrawdown), 'negative'],
			['Total Trades', evt.trades, ''],
			['Win Rate', evt.winRate + '%', ''],
			['Win / Loss / BL', evt.wins + ' / ' + evt.losses + (evt.breakevenLocks ? ' / ' + evt.breakevenLocks + ' BL' : ''), ''],
		];
		if (evt.sharpe != null) items.push(['Sharpe', evt.sharpe.toFixed(2), '']);
		if (evt.sortino != null) items.push(['Sortino', evt.sortino.toFixed(2), '']);
		if (evt.liquidated) {
			items.push(['Status', 'LIQUIDATED', 'liquidated']);
			liquidationSound.currentTime = 0;
			liquidationSound.play().catch(() => {});
		}

		elResultsGrid.innerHTML = '';
		items.forEach(([label, value, cls]) => {
			const div = document.createElement('div');
			div.className = 'info-item';
			div.innerHTML = '<span class="info-label">' + escapeHtml(label) + '</span>'
				+ '<span class="info-value' + (cls ? ' ' + cls : '') + '">' + escapeHtml(String(value)) + '</span>';
			elResultsGrid.appendChild(div);
		});
	}

	// =========================================================================
	// Utilities
	// =========================================================================
	function formatMoney(value) {
		const abs = Math.abs(value);
		const sign = value < 0 ? '-' : '';
		return sign + '\u20AE' + abs.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
	}

	function escapeHtml(str) {
		const div = document.createElement('div');
		div.textContent = str;
		return div.innerHTML;
	}

	// =========================================================================
	// Make XML
	// =========================================================================
	function generatePairXML() {
		const pairData = JSON.parse(elPair.value);
		const strategyName = elStrategy.value;
		const params = collectParams();
		const days = elDays.value;
		const balance = elBalance.value;
		const ticker = pairData.ticker;
		const timeframe = pairData.timeframe;

		const esc = (s) => String(s).replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

		let xml = '<pair ticker="' + esc(ticker) + '" timeframe="' + esc(timeframe) + '" trade="yes">\n';
		xml += '\t<strategy name="' + esc(strategyName) + '" backtest_days="' + esc(days) + '" backtest_initial_balance="' + esc(balance) + '">\n';

		for (const [key, val] of Object.entries(params)) {
			if (val === '' || val === undefined || val === null) continue;
			xml += '\t\t<param name="' + esc(key) + '" value="' + esc(val) + '"/>\n';
		}

		xml += '\t</strategy>\n';
		xml += '</pair>';
		return xml;
	}

	elMakeXmlBtn.addEventListener('click', () => {
		if (!elPair.value || !elStrategy.value) return;
		elXmlOutput.value = generatePairXML();
		elXmlOverlay.classList.add('active');
		elXmlOutput.focus();
		elXmlOutput.select();
	});

	elXmlCopy.addEventListener('click', () => {
		elXmlOutput.select();
		navigator.clipboard.writeText(elXmlOutput.value).then(() => {
			elXmlCopy.textContent = 'Copied!';
			setTimeout(() => { elXmlCopy.textContent = 'Copy'; }, 1500);
		});
	});

	elXmlClose.addEventListener('click', () => {
		elXmlOverlay.classList.remove('active');
	});

	elXmlOverlay.addEventListener('click', (e) => {
		if (e.target === elXmlOverlay) {
			elXmlOverlay.classList.remove('active');
		}
	});

	// =========================================================================
	// Load from Config
	// =========================================================================
	const elLoadConfigBtn = document.getElementById('btn-load-config');
	const elLoadConfigOverlay = document.getElementById('load-config-overlay');
	const elLoadConfigList = document.getElementById('load-config-list');

	function applyParamsToForm(cfg) {
		// Set strategy dropdown and re-render params.
		if (cfg.strategy) {
			const stratOpt = Array.from(elStrategy.options).find(o => o.value === cfg.strategy);
			if (stratOpt) {
				elStrategy.value = cfg.strategy;
				renderStrategyParams();
			}
		}

		// Fill param controls.
		if (cfg.params) {
			Object.entries(cfg.params).forEach(([key, val]) => {
				const el = document.getElementById('param-' + key);
				if (!el) return;
				if (el.dataset.paramType === 'bool') {
					el.checked = (val === 'true' || val === '1' || val === 'yes');
				} else {
					el.value = val;
				}
			});
			// Re-apply dependencies after setting values.
			const strat = strategies.find(s => s.name === cfg.strategy);
			if (strat) applyParamDependencies(strat.params);
		}

		// Fill days and balance if present.
		if (cfg.backtestDays) elDays.value = cfg.backtestDays;
		if (cfg.backtestInitialBalance) elBalance.value = cfg.backtestInitialBalance;
	}

	function selectPairDropdown(cfg) {
		const opt = Array.from(elPair.options).find(o => {
			try {
				const p = JSON.parse(o.value);
				return p.exchange === cfg.exchangeName
					&& p.ticker === cfg.ticker
					&& p.marketType === cfg.marketType
					&& p.timeframe === cfg.timeframe;
			} catch { return false; }
		});
		if (opt) elPair.value = opt.value;
	}

	elLoadConfigBtn.addEventListener('click', async () => {
		elLoadConfigList.innerHTML = '<li style="color:#666;font-style:italic;">Loading...</li>';
		elLoadConfigOverlay.classList.add('active');
		try {
			const resp = await fetch('/cgi-bin/api.pl?action=get_pair_configs');
			const configs = await resp.json();
			elLoadConfigList.innerHTML = '';
			if (configs.length === 0) {
				elLoadConfigList.innerHTML = '<li style="color:#666;">No pairs found in config.xml</li>';
				return;
			}
			configs.forEach(cfg => {
				const li = document.createElement('li');
				li.innerHTML = '<div class="pair-label">' + esc(cfg.ticker) + '</div>'
					+ '<div class="pair-meta">' + esc(cfg.exchangeName) + ' &middot; ' + esc(cfg.marketType) + ' &middot; ' + esc(cfg.timeframe) + ' &middot; ' + esc(cfg.strategy) + '</div>';
				li.addEventListener('click', () => {
					selectPairDropdown(cfg);
					applyParamsToForm(cfg);
					elLoadConfigOverlay.classList.remove('active');
				});
				elLoadConfigList.appendChild(li);
			});
		} catch (err) {
			elLoadConfigList.innerHTML = '<li style="color:#c62828;">Error: ' + esc(err.message) + '</li>';
		}
	});

	document.getElementById('btn-load-config-close').addEventListener('click', () => {
		elLoadConfigOverlay.classList.remove('active');
	});
	elLoadConfigOverlay.addEventListener('click', (e) => {
		if (e.target === elLoadConfigOverlay) elLoadConfigOverlay.classList.remove('active');
	});

	// =========================================================================
	// Load XML
	// =========================================================================
	const elLoadXmlBtn = document.getElementById('btn-load-xml');
	const elLoadXmlOverlay = document.getElementById('load-xml-overlay');
	const elLoadXmlInput = document.getElementById('load-xml-input');

	function parseAndApplyXml(xmlStr, hintExchange, hintMarketType) {
		const parser = new DOMParser();
		const doc = parser.parseFromString(xmlStr, 'text/xml');
		const parseError = doc.querySelector('parsererror');
		if (parseError) {
			alert('XML parse error: ' + parseError.textContent.substring(0, 200));
			return false;
		}

		const pairEl = doc.querySelector('pair');
		if (!pairEl) {
			alert('No <pair> element found in the XML.');
			return false;
		}

		const ticker = pairEl.getAttribute('ticker') || '';
		const timeframe = pairEl.getAttribute('timeframe') || '';

		// Try to select matching pair in dropdown (prefer exact match with exchange/marketType hints).
		if (ticker && timeframe) {
			const opts = Array.from(elPair.options);
			let best = null;
			for (const o of opts) {
				try {
					const p = JSON.parse(o.value);
					if (p.ticker !== ticker || p.timeframe !== timeframe) continue;
					if (!best) best = o;
					if (hintExchange && p.exchange === hintExchange && hintMarketType && p.marketType === hintMarketType) {
						best = o;
						break;
					}
				} catch { /* skip */ }
			}
			if (best) elPair.value = best.value;
		}

		const stratEl = pairEl.querySelector('strategy');
		if (!stratEl) {
			alert('No <strategy> element found inside <pair>.');
			return false;
		}

		const strategyName = stratEl.getAttribute('name') || '';
		const params = {};
		stratEl.querySelectorAll('param').forEach(p => {
			const name = p.getAttribute('name');
			const value = p.getAttribute('value');
			if (name) params[name] = value || '';
		});

		const cfg = {
			strategy: strategyName,
			params: params,
			backtestDays: stratEl.getAttribute('backtest_days') || null,
			backtestInitialBalance: stratEl.getAttribute('backtest_initial_balance') || null,
		};

		applyParamsToForm(cfg);
		return true;
	}

	elLoadXmlBtn.addEventListener('click', () => {
		elLoadXmlInput.value = '';
		elLoadXmlOverlay.classList.add('active');
		elLoadXmlInput.focus();
	});

	document.getElementById('btn-load-xml-apply').addEventListener('click', () => {
		const xml = elLoadXmlInput.value.trim();
		if (!xml) return;
		if (parseAndApplyXml(xml)) {
			elLoadXmlOverlay.classList.remove('active');
		}
	});

	document.getElementById('btn-load-xml-close').addEventListener('click', () => {
		elLoadXmlOverlay.classList.remove('active');
	});
	elLoadXmlOverlay.addEventListener('click', (e) => {
		if (e.target === elLoadXmlOverlay) elLoadXmlOverlay.classList.remove('active');
	});

	// =========================================================================
	// Escape helper (reusable)
	// =========================================================================
	function esc(s) {
		const d = document.createElement('div');
		d.textContent = String(s);
		return d.innerHTML;
	}

	// =========================================================================
	// Boot
	// =========================================================================
	init();
})();
</script>
{% endblock %}
